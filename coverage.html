
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>clients: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/viniciuscluna/tc-fiap-50/internal/infrastructure/clients/customer_client_impl.go (100.0%)</option>
				
				<option value="file1">github.com/viniciuscluna/tc-fiap-50/internal/infrastructure/clients/product_client_impl.go (76.2%)</option>
				
				<option value="file2">github.com/viniciuscluna/tc-fiap-50/internal/order/controller/order_controller_impl.go (90.5%)</option>
				
				<option value="file3">github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities/order.go (0.0%)</option>
				
				<option value="file4">github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities/order_product.go (0.0%)</option>
				
				<option value="file5">github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities/order_status.go (0.0%)</option>
				
				<option value="file6">github.com/viniciuscluna/tc-fiap-50/internal/order/presenter/order_presenter_impl.go (97.9%)</option>
				
				<option value="file7">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/addOrder/add_order_use_case_impl.go (82.8%)</option>
				
				<option value="file8">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands/add_order_command.go (100.0%)</option>
				
				<option value="file9">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands/get_order_command.go (100.0%)</option>
				
				<option value="file10">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands/get_order_status.go (100.0%)</option>
				
				<option value="file11">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands/get_orders_command.go (100.0%)</option>
				
				<option value="file12">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands/update_order_status_command.go (100.0%)</option>
				
				<option value="file13">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrder/get_order_use_case_impl.go (100.0%)</option>
				
				<option value="file14">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrderStatus/get_orders_status_use_case_impl.go (80.0%)</option>
				
				<option value="file15">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrders/get_orders_use_case_impl.go (80.0%)</option>
				
				<option value="file16">github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/updateOrderStatus/update_order_status_use_case._impl.go (80.0%)</option>
				
				<option value="file17">github.com/viniciuscluna/tc-fiap-50/internal/shared/httpclient/http_client.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package clients

import (
        "context"
        "fmt"

        "github.com/viniciuscluna/tc-fiap-50/internal/shared/httpclient"
)

type customerClientImpl struct {
        httpClient httpclient.HTTPClient
        baseURL    string
}

func NewCustomerClientImpl(httpClient httpclient.HTTPClient, baseURL string) CustomerClient <span class="cov10" title="4">{
        return &amp;customerClientImpl{
                httpClient: httpClient,
                baseURL:    baseURL,
        }
}</span>

func (c *customerClientImpl) GetCustomer(ctx context.Context, customerID uint) (*CustomerDTO, error) <span class="cov10" title="4">{
        url := fmt.Sprintf("%s/v1/customer/%d", c.baseURL, customerID)
        var customer CustomerDTO

        if err := c.httpClient.Get(ctx, url, &amp;customer); err != nil </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("failed to fetch customer %d: %w", customerID, err)
        }</span>

        <span class="cov5" title="2">return &amp;customer, nil</span>
}

func (c *customerClientImpl) ValidateCustomer(ctx context.Context, customerID uint) (bool, error) <span class="cov5" title="2">{
        customer, err := c.GetCustomer(ctx, customerID)
        if err != nil </span><span class="cov1" title="1">{
                // Check if it's a 404 error
                return false, nil
        }</span>

        <span class="cov1" title="1">return customer != nil &amp;&amp; customer.ID == customerID, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package clients

import (
        "context"
        "fmt"
        "strings"

        "github.com/viniciuscluna/tc-fiap-50/internal/shared/httpclient"
)

type productClientImpl struct {
        httpClient httpclient.HTTPClient
        baseURL    string
}

func NewProductClientImpl(httpClient httpclient.HTTPClient, baseURL string) ProductClient <span class="cov10" title="4">{
        return &amp;productClientImpl{
                httpClient: httpClient,
                baseURL:    baseURL,
        }
}</span>

func (c *productClientImpl) GetProduct(ctx context.Context, productID uint) (*ProductDTO, error) <span class="cov10" title="4">{
        url := fmt.Sprintf("%s/v1/product/%d", c.baseURL, productID)
        var product ProductDTO

        if err := c.httpClient.Get(ctx, url, &amp;product); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch product %d: %w", productID, err)
        }</span>

        <span class="cov10" title="4">return &amp;product, nil</span>
}

func (c *productClientImpl) GetProducts(ctx context.Context, productIDs []uint) ([]*ProductDTO, error) <span class="cov5" title="2">{
        if len(productIDs) == 0 </span><span class="cov1" title="1">{
                return []*ProductDTO{}, nil
        }</span>

        // Fetch products individually (can be optimized later with batch endpoint)
        <span class="cov1" title="1">products := make([]*ProductDTO, 0, len(productIDs))
        for _, productID := range productIDs </span><span class="cov5" title="2">{
                product, err := c.GetProduct(ctx, productID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch product %d: %w", productID, err)
                }</span>
                <span class="cov5" title="2">products = append(products, product)</span>
        }

        <span class="cov1" title="1">return products, nil</span>
}

func (c *productClientImpl) ValidateProduct(ctx context.Context, productID uint) (bool, error) <span class="cov1" title="1">{
        product, err := c.GetProduct(ctx, productID)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a 404 error
                if strings.Contains(err.Error(), "404") </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov1" title="1">return product != nil &amp;&amp; product.ID == productID, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "github.com/viniciuscluna/tc-fiap-50/internal/order/infrastructure/api/dto"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/presenter"
        addorder "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/addOrder"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
        getorder "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrder"
        getorderstatus "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrderStatus"
        getorders "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/getOrders"
        updateorderstatus "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/updateOrderStatus"
)

var (
        _ OrderController = (*OrderControllerImpl)(nil)
)

type OrderControllerImpl struct {
        presenter                presenter.OrderPresenter
        addOrderUseCase          addorder.AddOrderUseCase
        getOrderUseCase          getorder.GetOrderUseCase
        getOrdersUseCase         getorders.GetOrdersUseCase
        getOrderStatusUseCase    getorderstatus.GetOrderStatusUseCase
        updateOrderStatusUseCase updateorderstatus.UpdateOrderStatusUseCase
}

func NewOrderControllerImpl(
        presenter presenter.OrderPresenter,
        addOrderUseCase addorder.AddOrderUseCase,
        getOrderUseCase getorder.GetOrderUseCase,
        getOrdersUseCase getorders.GetOrdersUseCase,
        getOrderStatusUseCase getorderstatus.GetOrderStatusUseCase,
        updateOrderStatusUseCase updateorderstatus.UpdateOrderStatusUseCase) *OrderControllerImpl <span class="cov10" title="8">{
        return &amp;OrderControllerImpl{
                presenter:                presenter,
                addOrderUseCase:          addOrderUseCase,
                getOrderUseCase:          getOrderUseCase,
                getOrdersUseCase:         getOrdersUseCase,
                getOrderStatusUseCase:    getOrderStatusUseCase,
                updateOrderStatusUseCase: updateOrderStatusUseCase,
        }
}</span>

func (c *OrderControllerImpl) Add(addOrderRequest *dto.AddOrderDto) (string, error) <span class="cov4" title="2">{
        orderId, err := c.addOrderUseCase.Execute(commands.NewAddOrderCommand(
                *addOrderRequest.CustomerId,
                addOrderRequest.TotalAmount,
                addOrderRequest.Products))
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov1" title="1">return orderId, nil</span>
}

func (c *OrderControllerImpl) GetOrder(orderId uint) (*dto.GetOrderResponseDto, error) <span class="cov4" title="2">{
        order, err := c.getOrderUseCase.Execute(commands.NewGetOrderCommand(orderId))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return c.presenter.Present(order), nil</span>
}

func (c *OrderControllerImpl) GetOrders() (*dto.GetOrdersResponseDto, error) <span class="cov1" title="1">{
        orders, err := c.getOrdersUseCase.Execute(commands.NewGetOrdersCommand())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return c.presenter.PresentOrders(orders), nil</span>
}

func (c *OrderControllerImpl) GetOrderStatus(orderId uint) (*dto.GetOrderStatusResponseDto, error) <span class="cov1" title="1">{
        orderStatus, err := c.getOrderStatusUseCase.Execute(commands.NewGetOrderStatusCommand(orderId))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return c.presenter.PresentStatus(orderStatus), nil</span>
}

func (c *OrderControllerImpl) UpdateOrderStatus(orderId uint, updateOrderStatusRequest *dto.UpdateOrderStatusRequestDto) error <span class="cov4" title="2">{
        err := c.updateOrderStatusUseCase.Execute(commands.NewUpdateOrderStatusCommand(orderId, updateOrderStatusRequest.Status))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package entities

import (
        "time"
)

type OrderEntity struct {
        ID          uint                  `gorm:"primaryKey"`
        CreatedAt   time.Time             `gorm:"default:current_timestamp"`
        TotalAmount float32               `gorm:"default:0"`
        CustomerId  uint                  `gorm:"index"` // No pointer, no FK constraint - references external customer service
        Products    []*OrderProductEntity `gorm:"foreignKey:OrderId;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
        Status      []*OrderStatusEntity  `gorm:"foreignKey:OrderId;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (OrderEntity) TableName() string <span class="cov0" title="0">{
        return "order"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package entities

type OrderProductEntity struct {
        ID        uint        `gorm:"primaryKey"`
        OrderId   uint        `gorm:"index"`
        ProductId uint        `gorm:"index"` // No FK constraint - references external product service
        Price     float32     `gorm:"not null"`
        Quantity  uint        `gorm:"not null"`
        Order     OrderEntity `gorm:"foreignKey:OrderId;references:ID"`
}

func (OrderProductEntity) TableName() string <span class="cov0" title="0">{
        return "order_product"
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package entities

import (
        "time"
)

type OrderStatusEntity struct {
        ID            uint        `gorm:"primaryKey"`
        CreatedAt     time.Time   `gorm:"default:current_timestamp"`
        CurrentStatus uint        `gorm:"not null"`
        OrderId       uint        `gorm:"index"`
        Order         OrderEntity `gorm:"foreignKey:OrderId;references:ID"`
}

func (OrderStatusEntity) TableName() string <span class="cov0" title="0">{
        return "order_status"
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package presenter

import (
        "context"
        "errors"
        "log"
        "time"

        "github.com/viniciuscluna/tc-fiap-50/internal/infrastructure/clients"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/infrastructure/api/dto"
)

var (
        _ OrderPresenter = (*OrderPresenterImpl)(nil)
)

type OrderPresenterImpl struct {
        customerClient clients.CustomerClient
        productClient  clients.ProductClient
}

func NewOrderPresenterImpl(customerClient clients.CustomerClient, productClient clients.ProductClient) *OrderPresenterImpl <span class="cov9" title="17">{
        return &amp;OrderPresenterImpl{
                customerClient: customerClient,
                productClient:  productClient,
        }
}</span>

func (p *OrderPresenterImpl) Present(order *entities.OrderEntity) *dto.GetOrderResponseDto <span class="cov6" title="6">{
        ctx := context.Background()

        var customer *dto.GetCustomerResponseDto
        if order.CustomerId != 0 </span><span class="cov5" title="5">{
                // Fetch customer data from customer service
                customerData, err := p.customerClient.GetCustomer(ctx, order.CustomerId)
                if err != nil </span><span class="cov1" title="1">{
                        // Log error but don't fail - graceful degradation
                        log.Printf("failed to fetch customer %d: %v", order.CustomerId, err)
                }</span> else<span class="cov5" title="4"> {
                        customer = &amp;dto.GetCustomerResponseDto{
                                ID:    customerData.ID,
                                Name:  customerData.Name,
                                Email: customerData.Email,
                                CPF:   customerData.CPF,
                        }
                }</span>
        }

        <span class="cov6" title="6">return &amp;dto.GetOrderResponseDto{
                ID:          order.ID,
                CreatedAt:   order.CreatedAt,
                TotalAmount: order.TotalAmount,
                Customer:    customer,
                Products:    p.PresentProducts(order.Products),
                Status:      p.PresentMultipleStatus(order.Status),
        }</span>
}

func (p *OrderPresenterImpl) PresentOrders(orders []*entities.OrderEntity) *dto.GetOrdersResponseDto <span class="cov1" title="1">{
        orderDto := make([]*dto.GetOrderResponseDto, len(orders))

        for i, order := range orders </span><span class="cov3" title="2">{
                orderDto[i] = p.Present(order)
        }</span>

        <span class="cov1" title="1">return &amp;dto.GetOrdersResponseDto{
                Orders: orderDto,
        }</span>
}

func (p *OrderPresenterImpl) PresentProducts(orderProducts []*entities.OrderProductEntity) []*dto.OrderProductDto <span class="cov7" title="10">{
        ctx := context.Background()
        orderProductDtoArr := make([]*dto.OrderProductDto, len(orderProducts))

        // Collect all product IDs
        productIDs := make([]uint, len(orderProducts))
        for i, orderProduct := range orderProducts </span><span class="cov7" title="8">{
                productIDs[i] = orderProduct.ProductId
        }</span>

        // Fetch all products in batch from product service
        <span class="cov7" title="10">products, err := p.productClient.GetProducts(ctx, productIDs)
        if err != nil </span><span class="cov3" title="2">{
                log.Printf("failed to fetch products: %v", err)
                // Return products without enriched data
                for i, orderProduct := range orderProducts </span><span class="cov3" title="2">{
                        orderProductDtoArr[i] = &amp;dto.OrderProductDto{
                                ProductId: orderProduct.ProductId,
                                Price:     orderProduct.Price,
                                Quantity:  orderProduct.Quantity,
                        }
                }</span>
                <span class="cov3" title="2">return orderProductDtoArr</span>
        }

        // Create a map for quick lookup
        <span class="cov7" title="8">productMap := make(map[uint]*clients.ProductDTO)
        for _, product := range products </span><span class="cov6" title="6">{
                productMap[product.ID] = product
        }</span>

        // Enrich order products with product data
        <span class="cov7" title="8">for i, orderProduct := range orderProducts </span><span class="cov6" title="6">{
                product, exists := productMap[orderProduct.ProductId]
                if exists </span><span class="cov6" title="6">{
                        orderProductDtoArr[i] = &amp;dto.OrderProductDto{
                                ProductId:   orderProduct.ProductId,
                                Price:       orderProduct.Price,
                                Quantity:    orderProduct.Quantity,
                                Name:        product.Name,
                                ImageLink:   product.ImageLink,
                                Description: product.Description,
                                Category:    product.Category,
                        }
                }</span> else<span class="cov0" title="0"> {
                        // Product not found, return without enriched data
                        orderProductDtoArr[i] = &amp;dto.OrderProductDto{
                                ProductId: orderProduct.ProductId,
                                Price:     orderProduct.Price,
                                Quantity:  orderProduct.Quantity,
                        }
                }</span>
        }

        <span class="cov7" title="8">return orderProductDtoArr</span>
}

func (p *OrderPresenterImpl) PresentStatus(orderStatus *entities.OrderStatusEntity) *dto.GetOrderStatusResponseDto <span class="cov8" title="11">{
        statusDescription, err := GetStatusDescription(orderStatus.CurrentStatus)
        if err != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="10">return &amp;dto.GetOrderStatusResponseDto{
                ID:                       orderStatus.ID,
                CreatedAt:                orderStatus.CreatedAt.Format(time.RFC3339),
                CurrentStatus:            orderStatus.CurrentStatus,
                CurrentStatusDescription: statusDescription,
                OrderId:                  orderStatus.OrderId,
        }</span>
}

func (p *OrderPresenterImpl) PresentMultipleStatus(orderStatus []*entities.OrderStatusEntity) []*dto.GetOrderStatusResponseDto <span class="cov6" title="7">{
        orderStatusDtoArr := make([]*dto.GetOrderStatusResponseDto, len(orderStatus))

        for i, currentOrderStatus := range orderStatus </span><span class="cov5" title="4">{
                orderStatusDtoArr[i] = p.PresentStatus(currentOrderStatus)
        }</span>

        <span class="cov6" title="7">return orderStatusDtoArr</span>
}

// Obtain Description from CurrentStatus (id)
// 1 - Recebido
// 2 - Em preparação
// 3 - Pronto
// 4 - Finalizado
func GetStatusDescription(status uint) (string, error) <span class="cov10" title="21">{
        switch status </span>{
        case 1:<span class="cov6" title="7">
                return "Recebido", nil</span>
        case 2:<span class="cov5" title="5">
                return "Em preparação", nil</span>
        case 3:<span class="cov4" title="3">
                return "Pronto", nil</span>
        case 4:<span class="cov4" title="3">
                return "Finalizado", nil</span>
        default:<span class="cov4" title="3">
                return "", errors.New("status not found")</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package addorder

import (
        "context"
        "fmt"

        "github.com/viniciuscluna/tc-fiap-50/internal/infrastructure/clients"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/repositories"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
)

var (
        _ AddOrderUseCase = (*AddOrderUseCaseImpl)(nil)
)

type AddOrderUseCaseImpl struct {
        orderRepository        repositories.OrderRepository
        orderProductRepository repositories.OrderProductRepository
        orderStatusRepository  repositories.OrderStatusRepository
        customerClient         clients.CustomerClient
        productClient          clients.ProductClient
}

func NewAddOrderUseCaseImpl(
        orderRepository repositories.OrderRepository,
        orderProductRepository repositories.OrderProductRepository,
        orderStatusRepository repositories.OrderStatusRepository,
        customerClient clients.CustomerClient,
        productClient clients.ProductClient) *AddOrderUseCaseImpl <span class="cov10" title="3">{
        return &amp;AddOrderUseCaseImpl{
                orderRepository:        orderRepository,
                orderProductRepository: orderProductRepository,
                orderStatusRepository:  orderStatusRepository,
                customerClient:         customerClient,
                productClient:          productClient,
        }
}</span>

func (u *AddOrderUseCaseImpl) Execute(command *commands.AddOrderCommand) (string, error) <span class="cov10" title="3">{
        ctx := context.Background()

        // Validate customer exists
        if command.CustomerId != 0 </span><span class="cov10" title="3">{
                valid, err := u.customerClient.ValidateCustomer(ctx, command.CustomerId)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to validate customer: %w", err)
                }</span>
                <span class="cov10" title="3">if !valid </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("customer %d not found", command.CustomerId)
                }</span>
        }

        // Extract product IDs and validate all exist
        <span class="cov6" title="2">productIDs := make([]uint, len(command.Products))
        for i, p := range command.Products </span><span class="cov10" title="3">{
                productIDs[i] = p.ProductId
        }</span>

        <span class="cov6" title="2">products, err := u.productClient.GetProducts(ctx, productIDs)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to validate products: %w", err)
        }</span>
        <span class="cov6" title="2">if len(products) != len(productIDs) </span><span class="cov1" title="1">{
                return "", fmt.Errorf("some products not found")
        }</span>

        // Create order
        <span class="cov1" title="1">orderResult, err := u.orderRepository.AddOrder(&amp;entities.OrderEntity{
                CustomerId:  command.CustomerId,
                TotalAmount: command.TotalAmount,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Add order products
        <span class="cov1" title="1">for _, orderProductDto := range command.Products </span><span class="cov6" title="2">{
                orderProductEntity := &amp;entities.OrderProductEntity{
                        OrderId:   orderResult.ID,
                        ProductId: orderProductDto.ProductId,
                        Price:     orderProductDto.Price,
                        Quantity:  orderProductDto.Quantity,
                }
                err := u.orderProductRepository.AddOrderProduct(orderProductEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // Create initial order status
        <span class="cov1" title="1">orderStatusEntity := &amp;entities.OrderStatusEntity{
                OrderId:       orderResult.ID,
                CurrentStatus: 1,
        }
        err = u.orderStatusRepository.AddOrderStatus(orderStatusEntity)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("%d", orderResult.ID), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package commands

import "github.com/viniciuscluna/tc-fiap-50/internal/order/infrastructure/api/dto"

type AddOrderCommand struct {
        CustomerId  uint
        TotalAmount float32
        Products    []*dto.AddOrderProductDto
}

func NewAddOrderCommand(customerId uint, totalAmount float32, products []*dto.AddOrderProductDto) *AddOrderCommand <span class="cov10" title="5">{
        return &amp;AddOrderCommand{
                CustomerId:  customerId,
                TotalAmount: totalAmount,
                Products:    products,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package commands

type GetOrderCommand struct {
        OrderId uint
}

func NewGetOrderCommand(orderId uint) *GetOrderCommand <span class="cov10" title="4">{
        return &amp;GetOrderCommand{
                OrderId: orderId,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package commands

type GetOrderStatusCommand struct {
        OrderId uint
}

func NewGetOrderStatusCommand(orderId uint) *GetOrderStatusCommand <span class="cov10" title="2">{
        return &amp;GetOrderStatusCommand{
                OrderId: orderId,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package commands

type GetOrdersCommand struct {
}

func NewGetOrdersCommand() *GetOrdersCommand <span class="cov10" title="2">{
        return &amp;GetOrdersCommand{}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

type UpdateOrderStatusCommand struct {
        OrderId uint
        Status  uint
}

func NewUpdateOrderStatusCommand(orderId uint, status uint) *UpdateOrderStatusCommand <span class="cov10" title="3">{
        return &amp;UpdateOrderStatusCommand{
                OrderId: orderId,
                Status:  status,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package getorder

import (
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/repositories"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
)

var (
        _ GetOrderUseCase = (*GetOrderUseCaseImpl)(nil)
)

type GetOrderUseCaseImpl struct {
        orderRepository repositories.OrderRepository
}

func NewGetOrderUseCaseImpl(orderRepository repositories.OrderRepository) *GetOrderUseCaseImpl <span class="cov10" title="2">{
        return &amp;GetOrderUseCaseImpl{orderRepository: orderRepository}
}</span>

func (u *GetOrderUseCaseImpl) Execute(command *commands.GetOrderCommand) (*entities.OrderEntity, error) <span class="cov10" title="2">{
        order, err := u.orderRepository.GetOrder(command.OrderId)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return order, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package getorderstatus

import (
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/repositories"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
)

var (
        _ GetOrderStatusUseCase = (*GetOrderStatusUseCaseImpl)(nil)
)

type GetOrderStatusUseCaseImpl struct {
        orderStatusRepository repositories.OrderStatusRepository
}

func NewGetOrderStatusUseCaseImpl(orderStatusRepository repositories.OrderStatusRepository) *GetOrderStatusUseCaseImpl <span class="cov8" title="1">{
        return &amp;GetOrderStatusUseCaseImpl{orderStatusRepository: orderStatusRepository}
}</span>

func (u *GetOrderStatusUseCaseImpl) Execute(command *commands.GetOrderStatusCommand) (*entities.OrderStatusEntity, error) <span class="cov8" title="1">{
        orderStatus, err := u.orderStatusRepository.GetOrderStatus(command.OrderId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return orderStatus, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package getorders

import (
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/repositories"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
)

var (
        _ GetOrdersUseCase = (*GetOrdersUseCaseImpl)(nil)
)

type GetOrdersUseCaseImpl struct {
        orderRepository repositories.OrderRepository
}

func NewGetOrdersUseCaseImpl(orderRepository repositories.OrderRepository) *GetOrdersUseCaseImpl <span class="cov8" title="1">{
        return &amp;GetOrdersUseCaseImpl{orderRepository: orderRepository}
}</span>

func (u *GetOrdersUseCaseImpl) Execute(command *commands.GetOrdersCommand) ([]*entities.OrderEntity, error) <span class="cov8" title="1">{
        orders, err := u.orderRepository.GetOrders()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package updateorderstatus

import (
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/entities"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/domain/repositories"
        "github.com/viniciuscluna/tc-fiap-50/internal/order/usecase/commands"
)

var (
        _ UpdateOrderStatusUseCase = (*UpdateOrderStatusUseCaseImpl)(nil)
)

type UpdateOrderStatusUseCaseImpl struct {
        orderStatusRepository repositories.OrderStatusRepository
}

func NewUpdateOrderStatusUseCaseImpl(orderStatusRepository repositories.OrderStatusRepository) *UpdateOrderStatusUseCaseImpl <span class="cov8" title="1">{
        return &amp;UpdateOrderStatusUseCaseImpl{
                orderStatusRepository: orderStatusRepository,
        }
}</span>

func (u *UpdateOrderStatusUseCaseImpl) Execute(command *commands.UpdateOrderStatusCommand) error <span class="cov8" title="1">{
        err := u.orderStatusRepository.AddOrderStatus(&amp;entities.OrderStatusEntity{
                OrderId:       command.OrderId,
                CurrentStatus: command.Status,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httpclient

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

type HTTPClient interface {
        Get(ctx context.Context, url string, response interface{}) error
        Post(ctx context.Context, url string, body, response interface{}) error
}

type httpClientImpl struct {
        client  *http.Client
        retries int
        backoff time.Duration
}

func NewHTTPClient(timeout time.Duration, retries int, backoff time.Duration) HTTPClient <span class="cov10" title="8">{
        return &amp;httpClientImpl{
                client: &amp;http.Client{
                        Timeout: timeout,
                },
                retries: retries,
                backoff: backoff,
        }
}</span>

func (h *httpClientImpl) Get(ctx context.Context, url string, response interface{}) error <span class="cov10" title="8">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create GET request: %w", err)
        }</span>

        <span class="cov10" title="8">req.Header.Set("Content-Type", "application/json")

        return h.doWithRetry(req, response)</span>
}

func (h *httpClientImpl) Post(ctx context.Context, url string, body, response interface{}) error <span class="cov0" title="0">{
        var bodyReader io.Reader
        if body != nil </span><span class="cov0" title="0">{
                jsonBody, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">bodyReader = bytes.NewBuffer(jsonBody)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create POST request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        return h.doWithRetry(req, response)</span>
}

func (h *httpClientImpl) doWithRetry(req *http.Request, response interface{}) error <span class="cov10" title="8">{
        var lastErr error

        for attempt := 0; attempt &lt;= h.retries; attempt++ </span><span class="cov10" title="8">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Exponential backoff
                        backoffDuration := h.backoff * time.Duration(1&lt;&lt;uint(attempt-1))
                        time.Sleep(backoffDuration)
                }</span>

                <span class="cov10" title="8">resp, err := h.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP request failed (attempt %d/%d): %w", attempt+1, h.retries+1, err)
                        continue</span>
                }

                <span class="cov10" title="8">defer resp.Body.Close()

                if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov4" title="2">{
                        bodyBytes, _ := io.ReadAll(resp.Body)
                        lastErr = fmt.Errorf("HTTP request failed with status %d (attempt %d/%d): %s",
                                resp.StatusCode, attempt+1, h.retries+1, string(bodyBytes))

                        // Don't retry on 4xx errors (client errors)
                        if resp.StatusCode &gt;= 400 &amp;&amp; resp.StatusCode &lt; 500 </span><span class="cov4" title="2">{
                                return lastErr
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="6">if response != nil </span><span class="cov8" title="6">{
                        if err := json.NewDecoder(resp.Body).Decode(response); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to decode response: %w", err)
                        }</span>
                }

                <span class="cov8" title="6">return nil</span>
        }

        <span class="cov0" title="0">return lastErr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
